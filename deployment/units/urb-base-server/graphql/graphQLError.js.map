{"version":3,"sources":["../../../../units/urb-base-server/graphql/graphQLError.js"],"names":["setDefaultHandler","maskErrors","Processed","Symbol","IsUserError","UserError","args","name","message","Error","captureStackTrace","defaultHandler","err","log","error","stack","handlerFn","thing","fn","maskSchema","maskType","maskField","field","resolveFn","resolve","out","call","Promise","_resolveFn","type","getFields","fields","fieldName","Object","hasOwnProperty","schema","types","getTypeMap","typeName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCgBA,iB,CAAAA,iB;;;;;AAKAC,U,CAAAA,U,CAxChB,gCAEA,2B,w6BAGO,GAAMC,6BAAYC,QAAlB,CAGA,GAAMC,iCAAcD,QAApB,C,GAGME,U,SAAAA,S,8CACX,oBAAqB,wEAANC,IAAM,sCAANA,IAAM,6JACVA,IADU,IAEnB,MAAKC,IAAL,CAAY,OAAZ,CACA,MAAKC,OAAL,CAAeF,KAAK,CAAL,CAAf,CACA,MAAKF,WAAL,EAAoB,IAApB,CACAK,MAAMC,iBAAN,OAA8B,OAA9B,EALmB,aAMpB,C,mBAP4BD,K,EAWxB,GAAIE,uCAAiB,wBAASC,GAAT,CAAc,CACxC,GAAIA,IAAIR,WAAJ,CAAJ,CAAsB,CACpB,MAAOQ,IAAP,CACD,CAID,cAAIC,GAAJ,CAAQ,OAAR,CAAiB,yBAAjB,CAA4C,CAAEC,MAAQF,KAAOA,IAAIG,KAAZ,EAAsBH,GAA/B,CAA5C,EACAA,IAAIJ,OAAJ,kBACA,MAAOI,IAAP,CACD,CAVM,CAaA,QAASZ,kBAAT,CAA2BgB,SAA3B,CAAsC,CAC3C,QAdSL,cAcT,gBAAiBK,SAAjB,CACD,CAGM,QAASf,WAAT,CAAoBgB,KAApB,CAAgD,IAArBC,GAAqB,2DAAhBP,cAAgB;AACrD,GAAIM,uCAAJ,CAAoC;AAClCE,WAAWF,KAAX,CAAkBC,EAAlB;AACD,CAFD,IAEO,IAAID,2CAAJ,CAAwC;AAC7CG,SAASH,KAAT,CAAgBC,EAAhB;AACD,CAFM,IAEA;AACLG,UAAUJ,KAAV,CAAiBC,EAAjB;AACD;AACF;;AAED,QAASG,UAAT,CAAmBC,KAAnB,CAA0BJ,EAA1B,CAA8B;AAC5B,GAAMK,WAAYD,MAAME,OAAxB;AACA,GAAIF,MAAMpB,SAAN,GAAoB,CAACqB,SAAzB,CAAoC;AAClC;AACD;;AAEDD,MAAMpB,SAAN,EAAmB,IAAnB;AACAoB,MAAME,OAAN,CAAgB,mNAAkBlB,IAAlB,2CAAkBA,IAAlB;;AAENmB,GAFM,CAEAF,UAAUG,IAAV,kBAAe,IAAf,SAAwBpB,IAAxB,EAFA;AAGCqB,QAAQH,OAAR,CAAgBC,GAAhB,CAHD;;AAKNP,eALM,mEAAhB;;;;;AAUAI,MAAME,OAAN,CAAcI,UAAd,CAA2BL,SAA3B;AACD;;AAED,QAASH,SAAT,CAAkBS,IAAlB,CAAwBX,EAAxB,CAA4B;AAC1B,GAAIW,KAAK3B,SAAL,GAAmB,CAAC2B,KAAKC,SAA7B,CAAwC;AACtC;AACD;;AAED,GAAMC,QAASF,KAAKC,SAAL,EAAf;AACA,IAAK,GAAME,UAAX,GAAwBD,OAAxB,CAAgC;AAC9B,GAAI,CAACE,OAAOC,cAAP,CAAsBR,IAAtB,CAA2BK,MAA3B,CAAmCC,SAAnC,CAAL,CAAoD;AAClD;AACD;;AAEDX,UAAUU,OAAOC,SAAP,CAAV,CAA6Bd,EAA7B;AACD;AACF;;AAED,QAASC,WAAT,CAAoBgB,MAApB,CAA4BjB,EAA5B,CAAgC;AAC9B,GAAMkB,OAAQD,OAAOE,UAAP,EAAd;AACA,IAAK,GAAMC,SAAX,GAAuBF,MAAvB,CAA8B;AAC5B,GAAI,CAACH,OAAOC,cAAP,CAAsBR,IAAtB,CAA2BU,KAA3B,CAAkCE,QAAlC,CAAL,CAAkD;AAChD;AACD;;AAEDlB,SAASgB,MAAME,QAAN,CAAT,CAA0BpB,EAA1B;AACD;AACF","file":"graphQLError.js","sourcesContent":["// This is a modified version of: https://github.com/kadirahq/graphql-errors/blob/master/lib/index.js\n\n//import uuid from 'uuid';\nimport { GraphQLObjectType, GraphQLSchema } from 'graphql'\n\nimport log from '../log'\n\n// Mark field/type/schema\nexport const Processed = Symbol()\n\n// Used to identify UserErrors\nexport const IsUserError = Symbol()\n\n// UserErrors will be sent to the user\nexport class UserError extends Error {\n  constructor(...args) {\n    super(...args)\n    this.name = 'Error'\n    this.message = args[0]\n    this[IsUserError] = true\n    Error.captureStackTrace(this, 'Error')\n  }\n}\n\n// Modifies errors before sending to the user\nexport let defaultHandler = function(err) {\n  if (err[IsUserError]) {\n    return err\n  }\n  // TODO: x1000 Consider having a unique ID for the errors, most probably move it to the log though, so that all modules can use it\n  // const errId = uuid.v4();\n  // err.message = `${err.message}: ${errId}`;\n  log.log('error', 'Resolve function failed', { error: (err && err.stack) || err })\n  err.message = `Internal Error`\n  return err\n}\n\n// Changes the default error handler function\nexport function setDefaultHandler(handlerFn) {\n  defaultHandler = handlerFn\n}\n\n// Masks graphql schemas, types or individual fields\nexport function maskErrors(thing, fn = defaultHandler) {\n  if (thing instanceof GraphQLSchema) {\n    maskSchema(thing, fn)\n  } else if (thing instanceof GraphQLObjectType) {\n    maskType(thing, fn)\n  } else {\n    maskField(thing, fn)\n  }\n}\n\nfunction maskField(field, fn) {\n  const resolveFn = field.resolve\n  if (field[Processed] || !resolveFn) {\n    return\n  }\n\n  field[Processed] = true\n  field.resolve = async function(...args) {\n    try {\n      const out = resolveFn.call(this, ...args)\n      return await Promise.resolve(out)\n    } catch (e) {\n      throw fn(e)\n    }\n  }\n\n  // save the original resolve function\n  field.resolve._resolveFn = resolveFn\n}\n\nfunction maskType(type, fn) {\n  if (type[Processed] || !type.getFields) {\n    return\n  }\n\n  const fields = type.getFields()\n  for (const fieldName in fields) {\n    if (!Object.hasOwnProperty.call(fields, fieldName)) {\n      continue\n    }\n\n    maskField(fields[fieldName], fn)\n  }\n}\n\nfunction maskSchema(schema, fn) {\n  const types = schema.getTypeMap()\n  for (const typeName in types) {\n    if (!Object.hasOwnProperty.call(types, typeName)) {\n      continue\n    }\n\n    maskType(types[typeName], fn)\n  }\n}\n"]}