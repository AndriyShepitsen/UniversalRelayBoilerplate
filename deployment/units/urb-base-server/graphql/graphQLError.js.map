{"version":3,"sources":["../../../../units/urb-base-server/graphql/graphQLError.js"],"names":["setDefaultHandler","maskErrors","Processed","Symbol","IsUserError","UserError","args","name","message","Error","captureStackTrace","defaultHandler","err","log","error","stack","handlerFn","thing","fn","maskSchema","maskType","maskField","field","resolveFn","resolve","out","call","Promise","_resolveFn","type","getFields","fields","fieldName","Object","hasOwnProperty","schema","types","getTypeMap","typeName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCgBA,iB,CAAAA,iB;;;;;AAKAC,U,CAAAA,U,CA1ChB,gCAEA,2B,w6BAGO,GAAMC,6BAAYC,QAAlB,CAGA,GAAMC,iCAAcD,QAApB,C,GAGME,U,SAAAA,S,8CACX,oBAAuB,wEAAPC,IAAO,sCAAPA,IAAO,6JACXA,IADW,IAErB,MAAKC,IAAL,CAAY,OAAZ,CACA,MAAKC,OAAL,CAAeF,KAAK,CAAL,CAAf,CACA,MAAKF,WAAL,EAAoB,IAApB,CACAK,MAAMC,iBAAN,OAA+B,OAA/B,EALqB,aAMtB,C,mBAP4BD,K,EAWxB,GAAIE,uCAAiB,wBAAUC,GAAV,CAAgB,CAC1C,GAAKA,IAAIR,WAAJ,CAAL,CAAuB,CACrB,MAAOQ,IAAP,CACD,CAID,cAAIC,GAAJ,CAAS,OAAT,CAAkB,yBAAlB,CAA6C,CAC3CC,MAASF,KAAOA,IAAIG,KAAb,EAAwBH,GADY,CAA7C,EAGAA,IAAIJ,OAAJ,CAAc,gBAAd,CACA,MAAOI,IAAP,CACD,CAZM,CAeA,QAASZ,kBAAT,CAA4BgB,SAA5B,CAAwC,CAC7C,QAhBSL,cAgBT,gBAAiBK,SAAjB,CACD,CAGM,QAASf,WAAT,CAAqBgB,KAArB,CAAkD,IAAtBC,GAAsB,2DAAjBP,cAAiB;AACvD,GAAKM,uCAAL,CAAsC;AACpCE,WAAYF,KAAZ,CAAmBC,EAAnB;AACD,CAFD,IAEO,IAAKD,2CAAL,CAA0C;AAC/CG,SAAUH,KAAV,CAAiBC,EAAjB;AACD,CAFM,IAEA;AACLG,UAAWJ,KAAX,CAAkBC,EAAlB;AACD;AACF;;AAED,QAASG,UAAT,CAAoBC,KAApB,CAA2BJ,EAA3B,CAAgC;AAC9B,GAAMK,WAAYD,MAAME,OAAxB;AACA,GAAKF,MAAMpB,SAAN,GAAoB,CAACqB,SAA1B,CAAsC;AACpC;AACD;;AAEDD,MAAMpB,SAAN,EAAmB,IAAnB;AACAoB,MAAME,OAAN,CAAgB,mNAAmBlB,IAAnB,2CAAmBA,IAAnB;;AAENmB,GAFM,CAEAF,UAAUG,IAAV,kBAAgB,IAAhB,SAAyBpB,IAAzB,EAFA;AAGCqB,QAAQH,OAAR,CAAiBC,GAAjB,CAHD;;AAKNP,eALM,mEAAhB;;;;;AAUAI,MAAME,OAAN,CAAcI,UAAd,CAA2BL,SAA3B;AACD;;AAED,QAASH,SAAT,CAAmBS,IAAnB,CAAyBX,EAAzB,CAA8B;AAC5B,GAAKW,KAAK3B,SAAL,GAAmB,CAAC2B,KAAKC,SAA9B,CAA0C;AACxC;AACD;;AAED,GAAMC,QAASF,KAAKC,SAAL,EAAf;AACA,IAAM,GAAME,UAAZ,GAAyBD,OAAzB,CAAkC;AAChC,GAAK,CAACE,OAAOC,cAAP,CAAsBR,IAAtB,CAA4BK,MAA5B,CAAoCC,SAApC,CAAN,CAAwD;AACtD;AACD;;AAEDX,UAAWU,OAAOC,SAAP,CAAX,CAA8Bd,EAA9B;AACD;AACF;;AAED,QAASC,WAAT,CAAqBgB,MAArB,CAA6BjB,EAA7B,CAAkC;AAChC,GAAMkB,OAAQD,OAAOE,UAAP,EAAd;AACA,IAAM,GAAMC,SAAZ,GAAwBF,MAAxB,CAAgC;AAC9B,GAAK,CAACH,OAAOC,cAAP,CAAsBR,IAAtB,CAA4BU,KAA5B,CAAmCE,QAAnC,CAAN,CAAsD;AACpD;AACD;;AAEDlB,SAAUgB,MAAME,QAAN,CAAV,CAA2BpB,EAA3B;AACD;AACF","file":"graphQLError.js","sourcesContent":["// This is a modified version of: https://github.com/kadirahq/graphql-errors/blob/master/lib/index.js\n\n//import uuid from 'uuid';\nimport { GraphQLObjectType, GraphQLSchema } from 'graphql'\n\nimport log from '../log'\n\n// Mark field/type/schema\nexport const Processed = Symbol()\n\n// Used to identify UserErrors\nexport const IsUserError = Symbol()\n\n// UserErrors will be sent to the user\nexport class UserError extends Error {\n  constructor( ...args ) {\n    super( ...args )\n    this.name = 'Error'\n    this.message = args[0]\n    this[IsUserError] = true\n    Error.captureStackTrace( this, 'Error' )\n  }\n}\n\n// Modifies errors before sending to the user\nexport let defaultHandler = function( err ) {\n  if ( err[IsUserError]) {\n    return err\n  }\n  // TODO: x1000 Consider having a unique ID for the errors, most probably move it to the log though, so that all modules can use it\n  // const errId = uuid.v4();\n  // err.message = `${err.message}: ${errId}`;\n  log.log( 'error', 'Resolve function failed', {\n    error: ( err && err.stack ) || err,\n  })\n  err.message = 'Internal Error'\n  return err\n}\n\n// Changes the default error handler function\nexport function setDefaultHandler( handlerFn ) {\n  defaultHandler = handlerFn\n}\n\n// Masks graphql schemas, types or individual fields\nexport function maskErrors( thing, fn = defaultHandler ) {\n  if ( thing instanceof GraphQLSchema ) {\n    maskSchema( thing, fn )\n  } else if ( thing instanceof GraphQLObjectType ) {\n    maskType( thing, fn )\n  } else {\n    maskField( thing, fn )\n  }\n}\n\nfunction maskField( field, fn ) {\n  const resolveFn = field.resolve\n  if ( field[Processed] || !resolveFn ) {\n    return\n  }\n\n  field[Processed] = true\n  field.resolve = async function( ...args ) {\n    try {\n      const out = resolveFn.call( this, ...args )\n      return await Promise.resolve( out )\n    } catch ( e ) {\n      throw fn( e )\n    }\n  }\n\n  // save the original resolve function\n  field.resolve._resolveFn = resolveFn\n}\n\nfunction maskType( type, fn ) {\n  if ( type[Processed] || !type.getFields ) {\n    return\n  }\n\n  const fields = type.getFields()\n  for ( const fieldName in fields ) {\n    if ( !Object.hasOwnProperty.call( fields, fieldName ) ) {\n      continue\n    }\n\n    maskField( fields[fieldName], fn )\n  }\n}\n\nfunction maskSchema( schema, fn ) {\n  const types = schema.getTypeMap()\n  for ( const typeName in types ) {\n    if ( !Object.hasOwnProperty.call( types, typeName ) ) {\n      continue\n    }\n\n    maskType( types[typeName], fn )\n  }\n}\n"]}