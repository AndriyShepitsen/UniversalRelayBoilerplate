{"version":3,"sources":["../../../../units/urb-persister-memory/graphql/PersisterMemory.js"],"names":["Uuid_Null","PersisterMemory","stores","entityName","filter","store","getStore","arr_Indexes","map","objectInStore","index","filterMatched","filterField","push","arr_Objects","ObjectType","filters","findObjects","Promise","resolve","arr_arr_Objects","fields","newObject","newFields","id","an_Object","fieldName","indexToDelete","findIndexes","splice","str","v1","id1","id2","tableName","tableSchema","reject","runAsPartOfSetupDatabase","cb"],"mappings":"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","file":"PersisterMemory.js","sourcesContent":["// @flow\n\nimport uuid from 'node-uuid'\nimport winston from 'winston'\n\nconst Uuid_Null = '00000000-0000-0000-0000-000000000000'\n\nexport default class PersisterMemory {\n  stores: Object\n\n  constructor() {\n    this.stores = {}\n  }\n\n  getStore(entityName: string) {\n    if (entityName in this.stores) return this.stores[entityName]\n    else return (this.stores[entityName] = [])\n  }\n\n  findIndexes(entityName: string, filter: Object) {\n    const store = this.getStore(entityName)\n    const arr_Indexes = []\n\n    store.map((objectInStore, index) => {\n      let filterMatched = true\n      for (let filterField in filter)\n        if (objectInStore[filterField] != filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if (filterMatched) arr_Indexes.push(index)\n    })\n\n    return arr_Indexes\n  }\n\n  findObjects(entityName: string, filter: Object) {\n    const store = this.getStore(entityName)\n    const arr_Objects = []\n\n    store.map(objectInStore => {\n      let filterMatched = true\n      for (let filterField in filter)\n        if (objectInStore[filterField] != filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if (filterMatched) arr_Objects.push(objectInStore)\n    })\n\n    return arr_Objects\n  }\n\n  getOneObject(entityName: string, ObjectType: any, filters: Array<any>): Promise<any> {\n    const arr_Objects = filters.map(filter => this.findObjects(entityName, filter)[0])\n    return Promise.resolve(arr_Objects)\n  }\n\n  getObjectList(entityName: string, ObjectType: any, filters: Array<any>): Promise<Array<any>> {\n    const arr_arr_Objects = filters.map(filter => this.findObjects(entityName, filter))\n    return Promise.resolve(arr_arr_Objects)\n  }\n\n  add(entityName: string, fields: any, ObjectType: any) {\n    const store = this.getStore(entityName)\n    const newObject = new ObjectType(fields)\n\n    store.push(newObject)\n\n    return Promise.resolve()\n  }\n\n  update(entityName: string, fields: any): Promise<> {\n    // Only use the ID to find the record to delete\n    const newFields = {}\n    newFields.id = fields.id\n\n    const an_Object = this.findObjects(entityName, newFields)[0]\n\n    for (let fieldName in fields) an_Object[fieldName] = fields[fieldName]\n\n    return Promise.resolve()\n  }\n\n  remove(entityName: string, fields: any): Promise<> {\n    const store = this.getStore(entityName)\n\n    const indexToDelete = this.findIndexes(entityName, fields)[0]\n    store.splice(indexToDelete, 1)\n\n    return Promise.resolve()\n  }\n\n  createLogger() {\n    return null // No need for logger, by default it will output to console in dev mode\n  }\n\n  uuidFromString(str: string): string {\n    return str\n  }\n\n  uuidRandom(): string {\n    return uuid.v1()\n  }\n\n  uuidNull() {\n    return Uuid_Null\n  }\n\n  uuidNullAsString() {\n    return Uuid_Null\n  }\n\n  uuidToString(id: any) {\n    // ids are always strings anyway\n    return id\n  }\n\n  uuidEquals(id1: any, id2: any): boolean {\n    return id1 == id2\n  }\n\n  addTableSchema(tableName: string, tableSchema: Object): void {\n    // Nothing to do, it's all in memory\n  }\n\n  confirmHealth(): Promise<> {\n    return new Promise((resolve, reject) => {\n      resolve()\n    })\n  }\n\n  initialize(runAsPartOfSetupDatabase: boolean, cb: Function): void {\n    // Nothing to do, it's all in memory\n    cb()\n  }\n}\n"]}