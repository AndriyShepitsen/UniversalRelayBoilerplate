{"version":3,"sources":["../../../../units/urb-persister-elasticsearch/graphql/PersisterElasticSearch.js"],"names":["require","load","client","Client","host","process","env","ELASTIC_SEARCH_CONNECTION_POINTS","PersisterElasticSearch","stores","entityName","filter","store","getStore","arr_Indexes","objectInStore","index","filterMatched","filterField","push","arr_Objects","map","ObjectType","filters","findObjects","Promise","resolve","queries","resultPromises","reject","search","query","err","res","arrRetObj","hits","entity","_source","id","UserId","Mls","all","fields","newObject","newFields","an_Object","fieldName","indexToDelete","findIndexes","splice","str","id1","id2","tableName","tableSchema","runAsPartOfSetupDatabase","cb"],"mappings":"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","file":"PersisterElasticSearch.js","sourcesContent":["// @flow\n\nimport elasticsearch from 'elasticsearch'\n\nrequire('dotenv').load()\n\nconst client = new elasticsearch.Client({\n  host: process.env.ELASTIC_SEARCH_CONNECTION_POINTS,\n})\n\nexport default class PersisterElasticSearch {\n  stores = []\n\n  getStore(entityName: string) {\n    if (entityName in this.stores) return this.stores[entityName]\n    else return (this.stores[entityName] = [])\n  }\n\n  findIndexes(entityName: string, filter: Object) {\n    const store = this.getStore(entityName)\n    const arr_Indexes = []\n\n    for (let [ objectInStore, index ] of store) {\n      let filterMatched = true\n      for (let filterField in filter)\n        if (objectInStore[filterField] !== filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if (filterMatched) arr_Indexes.push(index)\n    }\n\n    return arr_Indexes\n  }\n\n  findObjects(entityName: string, filter: Object) {\n    const store = this.getStore(entityName)\n    const arr_Objects = []\n\n    store.map(objectInStore => {\n      let filterMatched = true\n      for (let filterField in filter)\n        if (objectInStore[filterField] !== filter[filterField]) {\n          filterMatched = false\n          break\n        }\n\n      if (filterMatched) arr_Objects.push(objectInStore)\n    })\n\n    return arr_Objects\n  }\n\n  getOneObject(\n    entityName: string,\n    ObjectType: any,\n    filters: Array<any>\n  ): Promise<any> {\n    const arr_Objects = filters.map(\n      filter => this.findObjects(entityName, filter)[0]\n    )\n    return Promise.resolve(arr_Objects)\n  }\n\n  getObjectList(\n    entityName: string,\n    ObjectType: any,\n    queries: Array<{\n      index: string,\n      type: string,\n      body: string\n    }>\n  ): Promise<any> {\n    const resultPromises = queries.map(query => {\n      return new Promise((resolve, reject) => {\n        client.search(query, (err, res) => {\n          if (err) reject(err)\n          else {\n            const arrRetObj = []\n            for (let entity of res.hits.hits) {\n              entity._source.id = entity._source.UserId || entity._source.Mls\n              arrRetObj.push(new ObjectType(entity._source))\n            }\n            resolve(arrRetObj)\n          }\n        })\n      })\n    })\n\n    return Promise.all(resultPromises)\n  }\n\n  add(entityName: string, fields: any, ObjectType: any): Promise<any> {\n    const store = this.getStore(entityName)\n    const newObject = new ObjectType(fields)\n\n    store.push(newObject)\n\n    return Promise.resolve()\n  }\n\n  update(entityName: string, fields: any): Promise<null> {\n    // Only use the ID to find the record to delete\n    const newFields = {}\n    newFields.id = fields.id\n\n    const an_Object = this.findObjects(entityName, newFields)[0]\n\n    for (let fieldName in fields) an_Object[fieldName] = fields[fieldName]\n\n    return Promise.resolve()\n  }\n\n  remove(entityName: string, fields: any): Promise<null> {\n    const store = this.getStore(entityName)\n\n    const indexToDelete = this.findIndexes(entityName, fields)[0]\n    store.splice(indexToDelete, 1)\n\n    return Promise.resolve()\n  }\n\n  createLogger() {\n    return null // No need for logger, by default it will output to console in dev mode\n  }\n\n  uuidFromString(str: string): string {\n    return str\n  }\n\n  uuidToString(id: any) {\n    // ids are always strings anyway\n    return id\n  }\n\n  uuidEquals(id1: any, id2: any): boolean {\n    return id1 === id2\n  }\n\n  addTableSchema(tableName: string, tableSchema: Object): void {\n    // Nothing to do, it's all in memory\n  }\n\n  confirmHealth(): Promise<null> {\n    return new Promise((resolve, reject) => {\n      resolve()\n    })\n  }\n\n  initialize(runAsPartOfSetupDatabase: boolean, cb: Function): void {\n    // Nothing to do, it's all in memory\n    // cb()\n  }\n}\n"]}